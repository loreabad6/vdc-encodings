---
title: "VDC encodings"
format: html
---

```{r}
library(stars)
```


## Files saved with `xvec.encode_cf()`
**CF conventions and netCDF, Zarr** section in [xvec development documentation](https://github.com/martinfleis/xvec/blob/summary/doc/source/io.ipynb)

Function: [here](https://github.com/martinfleis/xvec/blob/summary/xvec/accessor.py#L1343)

```{r}
fn_xvec_nc = "geo-encoded-xvec.nc"
fn_xvec_zr = "geo-encoded-xvec.zarr"
```

## Read with stars
```{r}
(nc = read_mdim(here::here(fn_xvec_nc)))
## Reading the zarr file crashes R!
# (zr = read_mdim(fn_zr))
```

## Write with stars 
```{r}
fn_stars_nc = "geo-encoded-stars.nc"
fn_stars_zr = "geo-encoded-stars.zarr"
write_mdim(nc, here::here(fn_stars_nc))
write_mdim(nc, here::here(fn_stars_zr))
```

## Check file structures
```{r}
ncmeta::nc_meta(here::here(fn_xvec_nc))
ncmeta::nc_meta(here::here(fn_stars_nc))

fs::dir_tree(here::here(fn_xvec_zr))
fs::dir_tree(here::here(fn_stars_zr))
```

## Read back with stars
```{r}
read_mdim(here::here(fn_stars_nc))
read_mdim(here::here(fn_stars_zr))
```

## Reading back with Python 
Code dump of test on Jupyter notebook

```
xr.open_dataset("geo-encoded-stars.nc", engine="netcdf4").xvec.decode_cf()

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
File /opt/conda/lib/python3.11/site-packages/numpy/core/fromnumeric.py:59, in _wrapfunc(obj, method, *args, **kwds)
     58 try:
---> 59     return bound(*args, **kwds)
     60 except TypeError:
     61     # A TypeError occurs if the object does have such a method in its
     62     # class, but its signature is not identical to that of NumPy's. This
   (...)
     66     # Call _wrapit from within the except clause to ensure a potential
     67     # exception has a traceback chain.

TypeError: Cannot cast array data from dtype('float32') to dtype('int64') according to the rule 'safe'

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
Cell In[2], line 1
----> 1 xr.open_dataset("../../data/raw/vdc-examples/geo-encoded-stars.nc", engine="netcdf4").xvec.decode_cf()

File /opt/conda/lib/python3.11/site-packages/xvec/accessor.py:1441, in XvecAccessor.decode_cf(self)
   1436 if not isinstance(self._obj, xr.Dataset):
   1437     raise ValueError(
   1438         "CF decoding is only supported on Datasets. Convert to a Dataset using `.to_dataset()` first."
   1439     )
-> 1441 decoded = cfxr.geometry.decode_geometries(self._obj.copy())
   1442 crs = {
   1443     name: CRS.from_user_input(var.attrs["crs_wkt"])
   1444     for name, var in decoded._variables.items()
   1445     if "crs_wkt" in var.attrs or "grid_mapping_name" in var.attrs
   1446 }
   1447 dims = decoded.xvec.geom_coords.dims

File /opt/conda/lib/python3.11/site-packages/cf_xarray/geometry.py:214, in decode_geometries(encoded)
    211 # Grab the coordinates attribute
    212 geom_attrs.update(enc_geom_var.encoding)
--> 214 geom_var = cf_to_shapely(encoded, container=container_name).variable
    216 todrop.extend(
    217     (container_name,)
    218     + tuple(
   (...)
    231     )
    232 )
    234 name = geom_attrs.get("variable_name", None)

File /opt/conda/lib/python3.11/site-packages/cf_xarray/geometry.py:539, in cf_to_shapely(ds, container)
    537     geometries = cf_to_lines(subds)
    538 elif geom_type == "polygon":
--> 539     geometries = cf_to_polygons(subds)
    540 else:
    541     raise ValueError(
    542         f"Valid CF geometry types are 'point', 'line' and 'polygon'. Got {geom_type}"
    543     )

File /opt/conda/lib/python3.11/site-packages/cf_xarray/geometry.py:944, in cf_to_polygons(ds)
    941         raise ValueError("coordinate array must start with an exterior ring")
    942     offset2 = np.append(np.where(interior_ring == 0)[0], [len(part_node_count)])
--> 944 polygons = from_ragged_array(GeometryType.POLYGON, xy, offsets=(offset1, offset2))
    946 # get index of offset2 values that are edges for node_count
    947 offset3 = np.nonzero(
    948     np.isin(
    949         offset2,
    950         np.nonzero(np.isin(offset1, np.insert(np.cumsum(node_count), 0, 0)))[0],
    951     )
    952 )[0]

File /opt/conda/lib/python3.11/site-packages/shapely/_ragged_array.py:445, in from_ragged_array(geometry_type, coords, offsets)
    443     return _linestring_from_flatcoords(coords, *offsets)
    444 if geometry_type == GeometryType.POLYGON:
--> 445     return _polygon_from_flatcoords(coords, *offsets)
    446 elif geometry_type == GeometryType.MULTIPOINT:
    447     return _multipoint_from_flatcoords(coords, *offsets)

File /opt/conda/lib/python3.11/site-packages/shapely/_ragged_array.py:369, in _polygon_from_flatcoords(coords, offsets1, offsets2)
    366 def _polygon_from_flatcoords(coords, offsets1, offsets2):
    367     # recreate rings
    368     ring_lengths = np.diff(offsets1)
--> 369     ring_indices = np.repeat(np.arange(len(ring_lengths)), ring_lengths)
    370     rings = creation.linearrings(coords, indices=ring_indices)
    372     # recreate polygons

File /opt/conda/lib/python3.11/site-packages/numpy/core/fromnumeric.py:466, in repeat(a, repeats, axis)
    423 @array_function_dispatch(_repeat_dispatcher)
    424 def repeat(a, repeats, axis=None):
    425     """
    426     Repeat each element of an array after themselves
    427 
   (...)
    464 
    465     """
--> 466     return _wrapfunc(a, 'repeat', repeats, axis=axis)

File /opt/conda/lib/python3.11/site-packages/numpy/core/fromnumeric.py:68, in _wrapfunc(obj, method, *args, **kwds)
     59     return bound(*args, **kwds)
     60 except TypeError:
     61     # A TypeError occurs if the object does have such a method in its
     62     # class, but its signature is not identical to that of NumPy's. This
   (...)
     66     # Call _wrapit from within the except clause to ensure a potential
     67     # exception has a traceback chain.
---> 68     return _wrapit(obj, method, *args, **kwds)

File /opt/conda/lib/python3.11/site-packages/numpy/core/fromnumeric.py:45, in _wrapit(obj, method, *args, **kwds)
     43 except AttributeError:
     44     wrap = None
---> 45 result = getattr(asarray(obj), method)(*args, **kwds)
     46 if wrap:
     47     if not isinstance(result, mu.ndarray):

TypeError: Cannot cast array data from dtype('float32') to dtype('int64') according to the rule 'safe'
```

```
xr.open_zarr("geo-encoded-stars.zarr").xvec.decode_cf()

---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:386, in _get_zarr_dims_and_attrs(zarr_obj, dimension_key, try_nczarr)
    384 try:
    385     # Xarray-Zarr
--> 386     dimensions = zarr_obj.attrs[dimension_key]
    387 except KeyError as e:

File /opt/conda/lib/python3.11/site-packages/zarr/core/attributes.py:21, in Attributes.__getitem__(self, key)
     20 def __getitem__(self, key: str) -> JSON:
---> 21     return self._obj.metadata.attributes[key]

KeyError: '_ARRAY_DIMENSIONS'

During handling of the above exception, another exception occurred:

TypeError                                 Traceback (most recent call last)
Cell In[4], line 1
----> 1 xr.open_zarr("../../data/raw/vdc-examples/geo-encoded-stars.zarr").xvec.decode_cf()

File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:1490, in open_zarr(store, group, synchronizer, chunks, decode_cf, mask_and_scale, decode_times, concat_characters, decode_coords, drop_variables, consolidated, overwrite_encoded_chunks, chunk_store, storage_options, decode_timedelta, use_cftime, zarr_version, zarr_format, use_zarr_fill_value_as_mask, chunked_array_type, from_array_kwargs, **kwargs)
   1476     raise TypeError(
   1477         "open_zarr() got unexpected keyword arguments " + ",".join(kwargs.keys())
   1478     )
   1480 backend_kwargs = {
   1481     "synchronizer": synchronizer,
   1482     "consolidated": consolidated,
   (...)
   1487     "zarr_format": zarr_format,
   1488 }
-> 1490 ds = open_dataset(
   1491     filename_or_obj=store,
   1492     group=group,
   1493     decode_cf=decode_cf,
   1494     mask_and_scale=mask_and_scale,
   1495     decode_times=decode_times,
   1496     concat_characters=concat_characters,
   1497     decode_coords=decode_coords,
   1498     engine="zarr",
   1499     chunks=chunks,
   1500     drop_variables=drop_variables,
   1501     chunked_array_type=chunked_array_type,
   1502     from_array_kwargs=from_array_kwargs,
   1503     backend_kwargs=backend_kwargs,
   1504     decode_timedelta=decode_timedelta,
   1505     use_cftime=use_cftime,
   1506     zarr_version=zarr_version,
   1507     use_zarr_fill_value_as_mask=use_zarr_fill_value_as_mask,
   1508 )
   1509 return ds

File /opt/conda/lib/python3.11/site-packages/xarray/backends/api.py:686, in open_dataset(filename_or_obj, engine, chunks, cache, decode_cf, mask_and_scale, decode_times, decode_timedelta, use_cftime, concat_characters, decode_coords, drop_variables, inline_array, chunked_array_type, from_array_kwargs, backend_kwargs, **kwargs)
    674 decoders = _resolve_decoders_kwargs(
    675     decode_cf,
    676     open_backend_dataset_parameters=backend.open_dataset_parameters,
   (...)
    682     decode_coords=decode_coords,
    683 )
    685 overwrite_encoded_chunks = kwargs.pop("overwrite_encoded_chunks", None)
--> 686 backend_ds = backend.open_dataset(
    687     filename_or_obj,
    688     drop_variables=drop_variables,
    689     **decoders,
    690     **kwargs,
    691 )
    692 ds = _dataset_from_backend_dataset(
    693     backend_ds,
    694     filename_or_obj,
   (...)
    704     **kwargs,
    705 )
    706 return ds

File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:1580, in ZarrBackendEntrypoint.open_dataset(self, filename_or_obj, mask_and_scale, decode_times, concat_characters, decode_coords, drop_variables, use_cftime, decode_timedelta, group, mode, synchronizer, consolidated, chunk_store, storage_options, zarr_version, zarr_format, store, engine, use_zarr_fill_value_as_mask, cache_members)
   1578 store_entrypoint = StoreBackendEntrypoint()
   1579 with close_on_error(store):
-> 1580     ds = store_entrypoint.open_dataset(
   1581         store,
   1582         mask_and_scale=mask_and_scale,
   1583         decode_times=decode_times,
   1584         concat_characters=concat_characters,
   1585         decode_coords=decode_coords,
   1586         drop_variables=drop_variables,
   1587         use_cftime=use_cftime,
   1588         decode_timedelta=decode_timedelta,
   1589     )
   1590 return ds

File /opt/conda/lib/python3.11/site-packages/xarray/backends/store.py:44, in StoreBackendEntrypoint.open_dataset(self, filename_or_obj, mask_and_scale, decode_times, concat_characters, decode_coords, drop_variables, use_cftime, decode_timedelta)
     30 def open_dataset(
     31     self,
     32     filename_or_obj: str | os.PathLike[Any] | ReadBuffer | AbstractDataStore,
   (...)
     40     decode_timedelta=None,
     41 ) -> Dataset:
     42     assert isinstance(filename_or_obj, AbstractDataStore)
---> 44     vars, attrs = filename_or_obj.load()
     45     encoding = filename_or_obj.get_encoding()
     47     vars, attrs, coord_names = conventions.decode_cf_variables(
     48         vars,
     49         attrs,
   (...)
     56         decode_timedelta=decode_timedelta,
     57     )

File /opt/conda/lib/python3.11/site-packages/xarray/backends/common.py:312, in AbstractDataStore.load(self)
    293 def load(self):
    294     """
    295     This loads the variables and attributes simultaneously.
    296     A centralized loading function makes it easier to create
   (...)
    309     are requested, so care should be taken to make sure its fast.
    310     """
    311     variables = FrozenDict(
--> 312         (_decode_variable_name(k), v) for k, v in self.get_variables().items()
    313     )
    314     attributes = FrozenDict(self.get_attrs())
    315     return variables, attributes

File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:856, in ZarrStore.get_variables(self)
    855 def get_variables(self):
--> 856     return FrozenDict((k, self.open_store_variable(k)) for k in self.array_keys())

File /opt/conda/lib/python3.11/site-packages/xarray/core/utils.py:457, in FrozenDict(*args, **kwargs)
    456 def FrozenDict(*args, **kwargs) -> Frozen:
--> 457     return Frozen(dict(*args, **kwargs))

File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:856, in <genexpr>(.0)
    855 def get_variables(self):
--> 856     return FrozenDict((k, self.open_store_variable(k)) for k in self.array_keys())

File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:814, in ZarrStore.open_store_variable(self, name)
    812 data = indexing.LazilyIndexedArray(ZarrArrayWrapper(zarr_array))
    813 try_nczarr = self._mode == "r"
--> 814 dimensions, attributes = _get_zarr_dims_and_attrs(
    815     zarr_array, DIMENSION_KEY, try_nczarr
    816 )
    817 attributes = dict(attributes)
    819 encoding = {
    820     "chunks": zarr_array.chunks,
    821     "preferred_chunks": dict(zip(dimensions, zarr_array.chunks, strict=True)),
    822 }

File /opt/conda/lib/python3.11/site-packages/xarray/backends/zarr.py:396, in _get_zarr_dims_and_attrs(zarr_obj, dimension_key, try_nczarr)
    394 # NCZarr defines dimensions through metadata in .zarray
    395 zarray_path = os.path.join(zarr_obj.path, ".zarray")
--> 396 zarray = json.loads(zarr_obj.store[zarray_path])
    397 try:
    398     # NCZarr uses Fully Qualified Names
    399     dimensions = [
    400         os.path.basename(dim) for dim in zarray["_NCZARR_ARRAY"]["dimrefs"]
    401     ]

TypeError: 'LocalStore' object is not subscriptable
```

